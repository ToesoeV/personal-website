<!DOCTYPE html>
<html lang="nl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="referrer" content="no-referrer">
    <meta http-equiv="Content-Security-Policy" content="default-src 'self' 'unsafe-inline' cdnjs.cloudflare.com; script-src 'self' 'unsafe-inline' cdnjs.cloudflare.com; style-src 'self' 'unsafe-inline'; img-src 'self' data:; connect-src 'self';">
    <title>Website in onderhoud</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            font-family: 'Arial', sans-serif;
            display: flex;
            flex-direction: column;
            height: 100vh;
        }
        /* Prevent touch-based zooming on mobile for the game area */
        html, body {
            touch-action: manipulation;
            -ms-touch-action: manipulation;
            -webkit-user-select: none;
            -ms-user-select: none;
            user-select: none;
            -webkit-touch-callout: none;
        }
        .game-container, #canvas {
            /* Disable pinch-zoom/double-tap-zoom for the interactive area */
            touch-action: none;
            -ms-touch-action: none;
        }
        .header {
            background: rgba(0,0,0,0.7);
            color: white;
            text-align: center;
            padding: 20px;
            backdrop-filter: blur(10px);
            z-index: 100;
            position: relative;
        }
        h1 {
            font-size: 2.5em;
            margin: 0 0 10px 0;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
        }
        p {
            font-size: 1.1em;
            margin: 5px 0;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
        }
        .instructions {
            background: rgba(0,0,0,0.3);
            padding: 15px;
            border-radius: 10px;
            backdrop-filter: blur(10px);
            margin: 10px auto;
            max-width: 600px;
        }
        .game-container {
            flex: 1;
            position: relative;
            overflow: hidden;
        }
        #canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
        .crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 20px;
            height: 20px;
            border: 2px solid white;
            border-radius: 50%;
            pointer-events: none;
            z-index: 10;
        }
        .crosshair::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 4px;
            height: 4px;
            background: white;
            border-radius: 50%;
        }
        .device-info {
            background: rgba(0,0,0,0.8);
            color: #00ff00;
            font-family: 'Courier New', monospace;
            font-size: 0.8em;
            padding: 10px;
            border-bottom: 2px solid rgba(0,255,0,0.3);
            display: none;
            white-space: pre-wrap;
            line-height: 1.2;
        }
        .permission-dialog {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.9);
            color: white;
            padding: 30px;
            border-radius: 15px;
            backdrop-filter: blur(15px);
            border: 2px solid rgba(255,255,255,0.2);
            text-align: center;
            z-index: 1000;
            max-width: 400px;
            display: none;
        }
        .permission-dialog h3 {
            margin-top: 0;
            color: #4ecdc4;
        }
        .permission-dialog button {
            margin: 10px;
            padding: 10px 20px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 1em;
        }
        .btn-allow {
            background: #4ecdc4;
            color: white;
        }
        .btn-deny {
            background: #ff6b6b;
            color: white;
        }
        
        /* Navigation Bar */
        .navbar {
            background: rgba(0,0,0,0.9);
            backdrop-filter: blur(15px);
            padding: 15px 0;
            position: sticky;
            top: 0;
            z-index: 1000;
            border-bottom: 2px solid rgba(255,255,255,0.1);
        }
        .nav-container {
            max-width: 1200px;
            margin: 0 auto;
            display: flex;
            justify-content: center;
            gap: 20px;
            padding: 0 20px;
        }
        .nav-tab {
            background: rgba(255,255,255,0.1);
            color: white;
            padding: 12px 25px;
            border: none;
            border-radius: 25px;
            cursor: pointer;
            font-size: 1em;
            font-weight: bold;
            transition: all 0.3s ease;
            text-decoration: none;
            display: inline-block;
        }
        .nav-tab:hover {
            background: rgba(255,255,255,0.2);
            transform: translateY(-2px);
        }
        .nav-tab.active {
            background: #4ecdc4;
            color: white;
            box-shadow: 0 4px 15px rgba(78, 205, 196, 0.3);
        }
        .nav-tab.external {
            background: rgba(255, 170, 0, 0.8);
        }
        .nav-tab.external:hover {
            background: rgba(255, 170, 0, 1);
        }
        
        /* Tab Content */
        .tab-content {
            display: none;
        }
        .tab-content.active {
            display: block;
        }
        
        /* Home Tab Styling */
        .home-content {
            text-align: center;
            padding: 40px 20px;
            max-width: 800px;
            margin: 0 auto;
        }
        
        /* Game Tab Styling */
        .game-tab {
            display: flex;
            flex-direction: column;
            height: calc(100vh - 80px);
        }
        
        /* Device Info Tab */
        .device-tab {
            padding: 20px;
            min-height: calc(100vh - 80px);
        }
        .device-info-tab {
            background: rgba(0,0,0,0.9);
            color: #00ff00;
            font-family: 'Courier New', monospace;
            font-size: 0.75em;
            padding: 20px;
            border-radius: 10px;
            white-space: pre-wrap;
            line-height: 1.3;
            overflow-x: auto;
        }
    </style>
</head>
<body>
    <!-- Navigation Bar -->
    <nav class="navbar">
        <div class="nav-container">
            <button class="nav-tab active" onclick="showTab('home')" id="home-tab">üè† Home</button>
            <button class="nav-tab" onclick="showTab('game')" id="game-tab">üéÆ Spelletje</button>
            <button class="nav-tab" onclick="showTab('device')" id="device-tab">üì± Apparaat Info</button>
            <a class="nav-tab external" href="https://tijdverschil.matthijsverburg.nl" target="_blank">üåç Tijdverschil</a>
        </div>
    </nav>

    <!-- Permission Dialog -->
    <div class="permission-dialog" id="permissionDialog">
        <h3>üîç Uitgebreide Apparaat Analyse</h3>
        <p>Mogen we uitgebreide technische informatie over je apparaat verzamelen en tonen?</p>
        <p style="font-size: 0.85em; color: #ccc;">
            Dit omvat: schermdata, sensoren (accelerometer, gyroscoop), locatie, audio/video apparaten, 
            batterijstatus, netwerk info, en alle beschikbare apparaat capabilities.
        </p>
        <p style="font-size: 0.8em; color: #ffaa00;">‚ö†Ô∏è Je browser kan om extra toestemmingen vragen voor sensoren/locatie</p>
        <button class="btn-allow" onclick="allowDeviceInfo()">üöÄ Ja, toon alles!</button>
        <button class="btn-deny" onclick="denyDeviceInfo()">‚ùå Nee, bedankt</button>
    </div>

    <!-- Tab Content -->
    <!-- Home Tab -->
    <div id="home-content" class="tab-content active">
        <div class="home-content">
            <div class="header">
                <h1>üöß Website in Onderhoud üöß</h1>
                <p>We werken hard aan vernieuwingen!</p>
                <div class="instructions">
                    <p><strong>Welkom bij Matthijs Verburg's website!</strong></p>
                    <p>De site is momenteel in onderhoud terwijl we nieuwe features en verbeteringen toevoegen.</p>
                    <br>
                    <p>üéÆ <strong>Spelletje:</strong> Probeer het kubus-schieten spel!</p>
                    <p>üì± <strong>Apparaat Info:</strong> Bekijk uitgebreide technische details van je apparaat</p>
                    <p>üåç <strong>Tijdverschil:</strong> Ontdek tijdzones wereldwijd</p>
                    <br>
                    <p>Bedankt voor je geduld terwijl we werken aan een betere ervaring.</p>
                </div>
            </div>
        </div>
    </div>

    <!-- Game Tab -->
    <div id="game-content" class="tab-content game-tab">
        <div class="header">
            <h1>üéÆ Kubus Schieten</h1>
            <p>Schiet op de bewegende kubussen voordat ze weggaan!</p>
            <div class="instructions">
                <p><strong>Spelregels:</strong></p>
                <p>üéØ Beweeg je muis/vinger om te richten</p>
                <p>üî´ Klik of tap om te schieten</p>
                <p>üí• Raak de kubussen voor punten!</p>
            </div>
        </div>
        
        <div class="game-container">
            <canvas id="canvas"></canvas>
            <div class="crosshair"></div>
        </div>
    </div>

    <!-- Device Info Tab -->
    <div id="device-content" class="tab-content device-tab">
        <div style="text-align: center; margin-bottom: 20px;">
            <h1 style="color: white; margin-bottom: 10px;">üì± Apparaat Informatie</h1>
            <p style="color: #ccc;">Uitgebreide technische details van je apparaat</p>
            <button class="btn-allow" onclick="requestDeviceInfo()" id="enableDeviceBtn">üîç Apparaat Data Inschakelen</button>
        </div>
        <div class="device-info-tab" id="deviceInfo" style="display: none;">
            <!-- Device information will be displayed here -->
        </div>
    </div>

    <script>
        // Game initialization variables
        let gameContainer;
        let canvas;
        let scene;
        let camera;
        let renderer;
        let gameInitialized = false;
        
        // Game objects
        let cubes = [];
        let projectiles = [];
        const colors = [0xff6b6b, 0x4ecdc4, 0x45b7d1, 0xffa726, 0x66bb6a, 0xab47bc];
        let score = 0;
        
        // Mouse and raycaster for interaction
        const mouse = new THREE.Vector2();
        const raycaster = new THREE.Raycaster();
        
        function initializeGame() {
            if (gameInitialized) return;
            
            // Check if Three.js is loaded
            if (typeof THREE === 'undefined') {
                console.error('THREE.js not loaded yet');
                setTimeout(initializeGame, 100);
                return;
            }
            
            // Get game container dimensions
            gameContainer = document.querySelector('.game-container');
            canvas = document.getElementById('canvas');
            
            if (!gameContainer || !canvas) {
                console.error('Game container or canvas not found');
                return;
            }
            
            // Three.js setup
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, gameContainer.offsetWidth / gameContainer.offsetHeight, 0.1, 1000);
            renderer = new THREE.WebGLRenderer({ canvas: canvas, alpha: true });
            
            resizeCanvas();
            renderer.setClearColor(0x000000, 0.1);
            
            // Initialize game objects
            initializeGameObjects();
            
            gameInitialized = true;
            
            // Log for debugging
            console.log('Game initialized successfully');
        }
        
        function resizeCanvas() {
            if (!gameContainer || !renderer) return;
            const rect = gameContainer.getBoundingClientRect();
            renderer.setSize(rect.width, rect.height);
            camera.aspect = rect.width / rect.height;
            camera.updateProjectionMatrix();
        }

        function initializeGameObjects() {
            // Reset game state
            cubes = [];
            projectiles = [];
            score = 0;
            
            // Create initial cubes
            for (let i = 0; i < 8; i++) {
                createCube();
            }

            // Position camera
            camera.position.z = 15;
            
            // Add event listeners
            if (gameContainer) {
                gameContainer.addEventListener('mousemove', onMouseMove);
                gameContainer.addEventListener('click', onMouseClick);
                gameContainer.addEventListener('touchmove', onTouchMove, { passive: false });
                gameContainer.addEventListener('touchend', onTouchEnd, { passive: false });
                console.log('Game event listeners attached');
            }
        }
        
        // Create moving cubes
        function createCube() {
            const geometry = new THREE.BoxGeometry(1, 1, 1);
            const material = new THREE.MeshBasicMaterial({ 
                color: colors[Math.floor(Math.random() * colors.length)],
                transparent: true,
                opacity: 0.8
            });
            const cube = new THREE.Mesh(geometry, material);
            
            // Adjust speed based on screen width (slower on mobile)
            const screenWidth = window.innerWidth;
            let speedMultiplier = 1.0;
            if (screenWidth <= 480) {
                speedMultiplier = 0.4; // Very slow on small phones
            } else if (screenWidth <= 768) {
                speedMultiplier = 0.6; // Moderate speed on tablets
            }
            
            // Start position (random edge of screen)
            const side = Math.floor(Math.random() * 4);
            switch(side) {
                case 0: // Left
                    cube.position.set(-15, (Math.random() - 0.5) * 10, (Math.random() - 0.5) * 10);
                    cube.velocity = new THREE.Vector3(0.1 * speedMultiplier, (Math.random() - 0.5) * 0.05 * speedMultiplier, (Math.random() - 0.5) * 0.05 * speedMultiplier);
                    break;
                case 1: // Right
                    cube.position.set(15, (Math.random() - 0.5) * 10, (Math.random() - 0.5) * 10);
                    cube.velocity = new THREE.Vector3(-0.1 * speedMultiplier, (Math.random() - 0.5) * 0.05 * speedMultiplier, (Math.random() - 0.5) * 0.05 * speedMultiplier);
                    break;
                case 2: // Top
                    cube.position.set((Math.random() - 0.5) * 20, 8, (Math.random() - 0.5) * 10);
                    cube.velocity = new THREE.Vector3((Math.random() - 0.5) * 0.05 * speedMultiplier, -0.1 * speedMultiplier, (Math.random() - 0.5) * 0.05 * speedMultiplier);
                    break;
                case 3: // Bottom
                    cube.position.set((Math.random() - 0.5) * 20, -8, (Math.random() - 0.5) * 10);
                    cube.velocity = new THREE.Vector3((Math.random() - 0.5) * 0.05 * speedMultiplier, 0.1 * speedMultiplier, (Math.random() - 0.5) * 0.05 * speedMultiplier);
                    break;
            }
            
            cube.rotation.x = Math.random() * Math.PI;
            cube.rotation.y = Math.random() * Math.PI;
            cube.rotationSpeed = {
                x: (Math.random() - 0.5) * 0.02,
                y: (Math.random() - 0.5) * 0.02
            };
            
            scene.add(cube);
            cubes.push(cube);
        }
        
        // Game will be initialized when switching to game tab

        function onMouseMove(event) {
            const rect = gameContainer.getBoundingClientRect();
            mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
        }

        function createProjectile(direction) {
            const geometry = new THREE.SphereGeometry(0.1, 8, 8);
            const material = new THREE.MeshBasicMaterial({ 
                color: 0xffff00,
                transparent: true,
                opacity: 0.9
            });
            const projectile = new THREE.Mesh(geometry, material);
            
            projectile.position.copy(camera.position);
            projectile.velocity = direction.multiplyScalar(0.5);
            projectile.life = 100; // frames to live
            
            scene.add(projectile);
            projectiles.push(projectile);
        }

        function onMouseClick(event) {
            raycaster.setFromCamera(mouse, camera);
            
            // Create projectile in the direction of the mouse
            const direction = new THREE.Vector3();
            raycaster.ray.direction.normalize();
            direction.copy(raycaster.ray.direction);
            
            createProjectile(direction);
            
            // Test vibration on first user interaction (if permission was granted)
            testVibrationOnInteraction();
        }
        
        function testVibrationOnInteraction() {
            if (window.deviceInfoVibrationAllowed && !window.vibrationTested && 'vibrate' in navigator) {
                try {
                    navigator.vibrate([50, 30, 50]); // Quick test vibration
                    window.vibrationTested = true;
                } catch (e) {
                    console.log('Vibration not available:', e.message);
                }
            }
        }

        // Collision detection
        function checkCollisions() {
            for (let i = projectiles.length - 1; i >= 0; i--) {
                const projectile = projectiles[i];
                
                for (let j = cubes.length - 1; j >= 0; j--) {
                    const cube = cubes[j];
                    const distance = projectile.position.distanceTo(cube.position);
                    
                    if (distance < 1) { // Hit!
                        // Remove projectile
                        scene.remove(projectile);
                        projectiles.splice(i, 1);
                        
                        // Animate cube exploding
                        const explodeCube = (cube) => {
                            cube.scale.multiplyScalar(1.1);
                            cube.rotation.x += 0.2;
                            cube.rotation.y += 0.2;
                            cube.material.opacity -= 0.05;
                            
                            if (cube.material.opacity > 0) {
                                requestAnimationFrame(() => explodeCube(cube));
                            } else {
                                scene.remove(cube);
                                const cubeIndex = cubes.indexOf(cube);
                                if (cubeIndex > -1) cubes.splice(cubeIndex, 1);
                                
                                // Add new cube after delay
                                setTimeout(createCube, 1000);
                            }
                        };
                        explodeCube(cube);
                        
                        score++;
                        break;
                    }
                }
            }
        }

        // Touch support for mobile shooting
        function onTouchMove(event) {
            if (event.touches.length === 1) {
                const touch = event.touches[0];
                const rect = gameContainer.getBoundingClientRect();
                mouse.x = ((touch.clientX - rect.left) / rect.width) * 2 - 1;
                mouse.y = -((touch.clientY - rect.top) / rect.height) * 2 + 1;
                event.preventDefault(); // Prevent scrolling
            }
        }

        function onTouchEnd(event) {
            if (event.changedTouches.length === 1) {
                // Shoot on single touch end (tap)
                raycaster.setFromCamera(mouse, camera);
                const direction = new THREE.Vector3();
                raycaster.ray.direction.normalize();
                direction.copy(raycaster.ray.direction);
                createProjectile(direction);
                event.preventDefault(); // Prevent mouse events from firing
                
                // Test vibration on first user interaction (if permission was granted)
                testVibrationOnInteraction();
            }
        }

        // Disable zoom on document level (outside game area)
        (function() {
          // Prevent double-tap to zoom on document (but not on game container)
          let lastTouchEnd = 0;
          document.addEventListener('touchend', function (event) {
            // Only prevent double-tap zoom if NOT in game container
            if (!gameContainer.contains(event.target)) {
              const now = (new Date()).getTime();
              if (now - lastTouchEnd <= 300) {
                event.preventDefault();
              }
              lastTouchEnd = now;
            }
          }, false);

          // Prevent pinch-zoom on iOS (document level)
          document.addEventListener('gesturestart', function (e) {
            e.preventDefault();
          });

          // Prevent multi-touch zoom gestures (2+ fingers) on document
          document.addEventListener('touchstart', function (e) {
            if (e.touches && e.touches.length > 1) {
              e.preventDefault();
            }
          }, { passive: false });
        })();

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            
            // Only run game logic if game is initialized and active
            if (!gameInitialized || !renderer || !scene) return;
            
            // Update cubes
            for (let i = cubes.length - 1; i >= 0; i--) {
                const cube = cubes[i];
                
                // Move cube
                cube.position.add(cube.velocity);
                
                // Rotate cube
                cube.rotation.x += cube.rotationSpeed.x;
                cube.rotation.y += cube.rotationSpeed.y;
                
                // Remove cubes that are too far away
                if (Math.abs(cube.position.x) > 20 || Math.abs(cube.position.y) > 12 || cube.position.z > 20) {
                    scene.remove(cube);
                    cubes.splice(i, 1);
                    
                    // Add new cube
                    setTimeout(createCube, Math.random() * 2000);
                }
            }
            
            // Update projectiles
            for (let i = projectiles.length - 1; i >= 0; i--) {
                const projectile = projectiles[i];
                
                // Move projectile
                projectile.position.add(projectile.velocity);
                
                // Remove old projectiles
                projectile.life--;
                if (projectile.life <= 0) {
                    scene.remove(projectile);
                    projectiles.splice(i, 1);
                }
            }
            
            // Check collisions
            checkCollisions();
            
            // Ensure minimum number of cubes
            while (cubes.length < 5) {
                createCube();
            }
            
            renderer.render(scene, camera);
        }

        // Handle window resize
        window.addEventListener('resize', resizeCanvas);

        // Tab Management
        function showTab(tabName) {
            // Hide all tab contents
            const tabContents = document.querySelectorAll('.tab-content');
            tabContents.forEach(tab => tab.classList.remove('active'));
            
            // Remove active class from all nav tabs
            const navTabs = document.querySelectorAll('.nav-tab:not(.external)');
            navTabs.forEach(tab => tab.classList.remove('active'));
            
            // Show selected tab content
            document.getElementById(tabName + '-content').classList.add('active');
            document.getElementById(tabName + '-tab').classList.add('active');
            
            // Initialize game if switching to game tab
            if (tabName === 'game') {
                console.log('Switching to game tab...');
                setTimeout(() => {
                    console.log('Initializing game...');
                    initializeGame();
                    resizeCanvas();
                }, 100);
            }
        }

        // Global variables for sensor data
        let sensorData = {
            accelerometer: { x: 'N/A', y: 'N/A', z: 'N/A', lastUpdate: 'Never' },
            gyroscope: { x: 'N/A', y: 'N/A', z: 'N/A', lastUpdate: 'Never' },
            orientation: { alpha: 'N/A', beta: 'N/A', gamma: 'N/A', lastUpdate: 'Never' },
            location: { latitude: 'N/A', longitude: 'N/A', accuracy: 'N/A', lastUpdate: 'Never' },
            battery: { level: 'N/A', charging: 'N/A', chargingTime: 'N/A', dischargingTime: 'N/A' },
            mediaDevices: [],
            permissions: {}
        };

        // Device information collection and display
        async function collectDeviceInfo() {
            const info = {
                // Screen and Display
                screenWidth: screen.width,
                screenHeight: screen.height,
                screenAvailWidth: screen.availWidth,
                screenAvailHeight: screen.availHeight,
                screenColorDepth: screen.colorDepth,
                screenPixelDepth: screen.pixelDepth,
                
                // Window/Viewport
                windowWidth: window.innerWidth,
                windowHeight: window.innerHeight,
                windowOuterWidth: window.outerWidth,
                windowOuterHeight: window.outerHeight,
                devicePixelRatio: window.devicePixelRatio,
                
                // Browser and OS
                userAgent: navigator.userAgent,
                platform: navigator.platform,
                language: navigator.language,
                languages: navigator.languages ? navigator.languages.join(', ') : 'N/A',
                cookieEnabled: window.location.protocol === 'file:' ? 'N/A (file://)' : navigator.cookieEnabled,
                onLine: navigator.onLine,
                vendor: navigator.vendor || 'N/A',
                product: navigator.product || 'N/A',
                appName: navigator.appName || 'N/A',
                appVersion: navigator.appVersion || 'N/A',
                
                // Hardware
                hardwareConcurrency: navigator.hardwareConcurrency || 'N/A',
                maxTouchPoints: navigator.maxTouchPoints || 'N/A',
                deviceMemory: navigator.deviceMemory ? navigator.deviceMemory + ' GB' : 'N/A',
                
                // Time and Location
                timezone: Intl.DateTimeFormat().resolvedOptions().timeZone,
                timestamp: new Date().toISOString(),
                
                // Network Connection
                connectionType: navigator.connection ? navigator.connection.effectiveType : 'N/A',
                connectionDownlink: navigator.connection ? navigator.connection.downlink + ' Mbps' : 'N/A',
                connectionRtt: navigator.connection ? navigator.connection.rtt + ' ms' : 'N/A',
                connectionSaveData: navigator.connection ? navigator.connection.saveData : 'N/A',
                
                // Orientation
                orientation: screen.orientation ? screen.orientation.type : 'N/A',
                orientationAngle: screen.orientation ? screen.orientation.angle + '¬∞' : 'N/A',
                
                // WebGL and Graphics
                webglSupport: 'N/A',
                webglRenderer: 'N/A',
                webglVendor: 'N/A',
                
                // Audio Context
                audioContextSupport: 'N/A',
                audioMaxChannels: 'N/A',
                audioSampleRate: 'N/A',
                
                // Permissions API
                permissionsSupport: 'permissions' in navigator,
                
                // Storage
                localStorage: 'localStorage' in window,
                sessionStorage: 'sessionStorage' in window,
                indexedDB: 'indexedDB' in window,
                
                // Advanced APIs
                serviceWorker: 'serviceWorker' in navigator,
                geolocation: 'geolocation' in navigator,
                vibration: 'vibrate' in navigator,
                clipboard: 'clipboard' in navigator,
                share: 'share' in navigator,
                
                // Sensor data (live updating)
                sensorData: sensorData
            };
            
            // Get WebGL info
            try {
                const canvas = document.createElement('canvas');
                const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
                if (gl) {
                    info.webglSupport = 'Supported';
                    const debugInfo = gl.getExtension('WEBGL_debug_renderer_info');
                    if (debugInfo) {
                        info.webglRenderer = gl.getParameter(debugInfo.UNMASKED_RENDERER_WEBGL);
                        info.webglVendor = gl.getParameter(debugInfo.UNMASKED_VENDOR_WEBGL);
                    }
                }
            } catch (e) {
                info.webglSupport = 'Error: ' + e.message;
            }
            
            // Get Audio Context info
            try {
                const AudioContext = window.AudioContext || window.webkitAudioContext;
                if (AudioContext) {
                    const audioCtx = new AudioContext();
                    info.audioContextSupport = 'Supported';
                    info.audioMaxChannels = audioCtx.destination.maxChannelCount || 'N/A';
                    info.audioSampleRate = audioCtx.sampleRate + ' Hz' || 'N/A';
                    audioCtx.close();
                }
            } catch (e) {
                info.audioContextSupport = 'Error: ' + e.message;
            }
            
            // Get Media Devices
            if (navigator.mediaDevices && navigator.mediaDevices.enumerateDevices) {
                try {
                    const devices = await navigator.mediaDevices.enumerateDevices();
                    sensorData.mediaDevices = devices.map(device => ({
                        kind: device.kind,
                        label: device.label || 'Unknown Device',
                        deviceId: device.deviceId.substring(0, 20) + '...'
                    }));
                } catch (e) {
                    sensorData.mediaDevices = ['Error: ' + e.message];
                }
            }
            
            // Get Battery Status
            if ('getBattery' in navigator) {
                try {
                    const battery = await navigator.getBattery();
                    sensorData.battery = {
                        level: Math.round(battery.level * 100) + '%',
                        charging: battery.charging ? 'üîå Charging' : 'üîã Not Charging',
                        chargingTime: battery.chargingTime === Infinity ? 'N/A' : Math.round(battery.chargingTime / 60) + ' min',
                        dischargingTime: battery.dischargingTime === Infinity ? 'N/A' : Math.round(battery.dischargingTime / 60) + ' min'
                    };
                } catch (e) {
                    sensorData.battery = { error: e.message };
                }
            }
            
            return info;
        }
        
        // Initialize sensor listeners
        function initializeSensors() {
            // Motion sensors
            if (window.DeviceMotionEvent) {
                window.addEventListener('devicemotion', function(event) {
                    if (event.acceleration) {
                        sensorData.accelerometer = {
                            x: event.acceleration.x ? event.acceleration.x.toFixed(3) : 'N/A',
                            y: event.acceleration.y ? event.acceleration.y.toFixed(3) : 'N/A',
                            z: event.acceleration.z ? event.acceleration.z.toFixed(3) : 'N/A',
                            lastUpdate: new Date().toLocaleTimeString('nl-NL')
                        };
                    }
                    if (event.rotationRate) {
                        sensorData.gyroscope = {
                            x: event.rotationRate.alpha ? event.rotationRate.alpha.toFixed(3) : 'N/A',
                            y: event.rotationRate.beta ? event.rotationRate.beta.toFixed(3) : 'N/A',
                            z: event.rotationRate.gamma ? event.rotationRate.gamma.toFixed(3) : 'N/A',
                            lastUpdate: new Date().toLocaleTimeString('nl-NL')
                        };
                    }
                });
            }
            
            // Orientation sensor
            if (window.DeviceOrientationEvent) {
                window.addEventListener('deviceorientation', function(event) {
                    sensorData.orientation = {
                        alpha: event.alpha ? event.alpha.toFixed(1) + '¬∞' : 'N/A',
                        beta: event.beta ? event.beta.toFixed(1) + '¬∞' : 'N/A',
                        gamma: event.gamma ? event.gamma.toFixed(1) + '¬∞' : 'N/A',
                        lastUpdate: new Date().toLocaleTimeString('nl-NL')
                    };
                });
            }
            
            // Request motion sensor permissions on iOS 13+
            if (typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function') {
                DeviceOrientationEvent.requestPermission().catch(console.error);
            }
            if (typeof DeviceMotionEvent !== 'undefined' && typeof DeviceMotionEvent.requestPermission === 'function') {
                DeviceMotionEvent.requestPermission().catch(console.error);
            }
        }
        
        // Get geolocation
        function getLocation() {
            if (navigator.geolocation) {
                navigator.geolocation.getCurrentPosition(
                    function(position) {
                        sensorData.location = {
                            latitude: position.coords.latitude.toFixed(6),
                            longitude: position.coords.longitude.toFixed(6),
                            accuracy: position.coords.accuracy.toFixed(0) + 'm',
                            altitude: position.coords.altitude ? position.coords.altitude.toFixed(1) + 'm' : 'N/A',
                            speed: position.coords.speed ? position.coords.speed.toFixed(1) + 'm/s' : 'N/A',
                            lastUpdate: new Date().toLocaleTimeString('nl-NL')
                        };
                    },
                    function(error) {
                        sensorData.location = {
                            error: error.message,
                            lastUpdate: new Date().toLocaleTimeString('nl-NL')
                        };
                    },
                    { enableHighAccuracy: true, timeout: 10000, maximumAge: 60000 }
                );
            }
        }

        function displayDeviceInfo(deviceInfo) {
            const deviceInfoEl = document.getElementById('deviceInfo');
            const sData = deviceInfo.sensorData;
            
            const formatInfo = `
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
ÔøΩ UITGEBREIDE APPARAAT ANALYSE                                      ÔøΩ ${new Date().toLocaleString('nl-NL')}
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

üìê SCHERM & DISPLAY:
   Schermresolutie: ${deviceInfo.screenWidth} √ó ${deviceInfo.screenHeight} pixels
   Beschikbaar Scherm: ${deviceInfo.screenAvailWidth} √ó ${deviceInfo.screenAvailHeight} pixels
   Browser Venster: ${deviceInfo.windowWidth} √ó ${deviceInfo.windowHeight} pixels
   Outer Venster: ${deviceInfo.windowOuterWidth} √ó ${deviceInfo.windowOuterHeight} pixels
   Pixel Ratio: ${deviceInfo.devicePixelRatio}x (${deviceInfo.screenColorDepth}-bit kleuren)
   Ori√´ntatie: ${deviceInfo.orientation} (${deviceInfo.orientationAngle})

üåê BROWSER & SYSTEEM:
   Browser: ${deviceInfo.appName} v${deviceInfo.appVersion}
   Platform: ${deviceInfo.platform} | Vendor: ${deviceInfo.vendor}
   Product: ${deviceInfo.product}
   Taal: ${deviceInfo.language} | Alle Talen: ${deviceInfo.languages}
   Online: ${deviceInfo.onLine ? 'üü¢' : 'üî¥'} | Cookies: ${typeof deviceInfo.cookieEnabled === 'string' ? deviceInfo.cookieEnabled : (deviceInfo.cookieEnabled ? '‚úÖ' : '‚ùå')}

‚öôÔ∏è  HARDWARE & PRESTATIES:
   CPU Kernen: ${deviceInfo.hardwareConcurrency} | RAM: ${deviceInfo.deviceMemory}
   Touch Points: ${deviceInfo.maxTouchPoints}
   WebGL: ${deviceInfo.webglSupport}
   GPU Renderer: ${deviceInfo.webglRenderer}
   GPU Vendor: ${deviceInfo.webglVendor}

üîä AUDIO SYSTEEM:
   Audio Context: ${deviceInfo.audioContextSupport}
   Max Kanalen: ${deviceInfo.audioMaxChannels} | Sample Rate: ${deviceInfo.audioSampleRate}

üì° NETWERK & VERBINDING:
   Type: ${deviceInfo.connectionType} | Snelheid: ${deviceInfo.connectionDownlink}
   Latency (RTT): ${deviceInfo.connectionRtt} | Data Besparing: ${deviceInfo.connectionSaveData}
   Tijdzone: ${deviceInfo.timezone}

üîã BATTERIJ STATUS:
   Niveau: ${sData.battery.level} | Status: ${sData.battery.charging}
   Oplaadtijd: ${sData.battery.chargingTime} | Ontlaadtijd: ${sData.battery.dischargingTime}

üìç LOCATIE DATA:
   Co√∂rdinaten: ${sData.location.latitude}, ${sData.location.longitude}
   Nauwkeurigheid: ${sData.location.accuracy} | Hoogte: ${sData.location.altitude || 'N/A'}
   Snelheid: ${sData.location.speed || 'N/A'} | Update: ${sData.location.lastUpdate}

üéØ BEWEGINGSSENSOREN:
   Accelerometer (m/s¬≤): X:${sData.accelerometer.x} Y:${sData.accelerometer.y} Z:${sData.accelerometer.z}
   Update: ${sData.accelerometer.lastUpdate}
   
   Gyroscoop (rad/s): X:${sData.gyroscope.x} Y:${sData.gyroscope.y} Z:${sData.gyroscope.z}
   Update: ${sData.gyroscope.lastUpdate}
   
   Ori√´ntatie: Œ±:${sData.orientation.alpha} Œ≤:${sData.orientation.beta} Œ≥:${sData.orientation.gamma}
   Update: ${sData.orientation.lastUpdate}

üé• MEDIA APPARATEN:
${sData.mediaDevices.length > 0 ? sData.mediaDevices.map(device => 
   `   ${device.kind === 'audioinput' ? 'üé§' : device.kind === 'audiooutput' ? 'üîä' : 'üìπ'} ${device.label} (${device.deviceId})`).join('\n') : '   Geen apparaten gevonden of toegang geweigerd'}

üõ†Ô∏è  API ONDERSTEUNING:
   Service Worker: ${deviceInfo.serviceWorker ? '‚úÖ' : '‚ùå'} | Geolocation: ${deviceInfo.geolocation ? '‚úÖ' : '‚ùå'}
   Vibration: ${deviceInfo.vibration ? '‚úÖ' : '‚ùå'} | Clipboard: ${deviceInfo.clipboard ? '‚úÖ' : '‚ùå'}
   Share API: ${deviceInfo.share ? '‚úÖ' : '‚ùå'} | Permissions API: ${deviceInfo.permissionsSupport ? '‚úÖ' : '‚ùå'}
   
üíæ OPSLAG SYSTEMEN:
   LocalStorage: ${deviceInfo.localStorage ? '‚úÖ' : '‚ùå'} | SessionStorage: ${deviceInfo.sessionStorage ? '‚úÖ' : '‚ùå'}
   IndexedDB: ${deviceInfo.indexedDB ? '‚úÖ' : '‚ùå'}

üîç USER AGENT STRING:
   ${deviceInfo.userAgent}

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
üí° LIVE DATA: Sensoren updaten automatisch | Laatst vernieuwd: ${new Date().toLocaleTimeString('nl-NL')}
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê`;

            deviceInfoEl.textContent = formatInfo;
            deviceInfoEl.style.display = 'block';
            
            // Hide the enable button
            const enableBtn = document.getElementById('enableDeviceBtn');
            if (enableBtn) enableBtn.style.display = 'none';
            
            // Auto-refresh every 5 seconds to show live sensor data
            if (!window.deviceInfoInterval) {
                window.deviceInfoInterval = setInterval(() => {
                    collectDeviceInfo().then(displayDeviceInfo);
                }, 5000);
            }
        }

        // New function for device info tab button
        function requestDeviceInfo() {
            document.getElementById('permissionDialog').style.display = 'block';
        }

        async function allowDeviceInfo() {
            // Initialize all sensors and data collection
            initializeSensors();
            getLocation();
            
            // Collect and display initial device info
            const deviceInfo = await collectDeviceInfo();
            displayDeviceInfo(deviceInfo);
            document.getElementById('permissionDialog').style.display = 'none';
            
            // Store that user has given permission for vibration test
            window.deviceInfoVibrationAllowed = true;
            
            // Store preference
            localStorage.setItem('deviceInfoAllowed', 'true');
        }

        function denyDeviceInfo() {
            document.getElementById('permissionDialog').style.display = 'none';
            localStorage.setItem('deviceInfoAllowed', 'false');
        }

        // Check if user has already given permission
        async function checkPermission() {
            const allowed = localStorage.getItem('deviceInfoAllowed');
            if (allowed === 'true') {
                // Auto-enable device info if previously allowed
                const enableBtn = document.getElementById('enableDeviceBtn');
                if (enableBtn) enableBtn.style.display = 'none';
                await allowDeviceInfo();
            }
            // No longer show dialog automatically - only when user clicks button
        }

        // Initialize permission check
        checkPermission();

        // Start the animation loop (but game logic only runs when initialized)
        animate();
    </script>
</body>
</html>